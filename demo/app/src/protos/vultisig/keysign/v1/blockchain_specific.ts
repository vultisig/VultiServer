/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: vultisig/keysign/v1/blockchain_specific.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace vultisig.keysign.v1 {
    export enum TransactionType {
        TRANSACTION_TYPE_UNSPECIFIED = 0,
        TRANSACTION_TYPE_VOTE = 1,
        TRANSACTION_TYPE_PROPOSAL = 2
    }
    export class UTXOSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            byte_fee?: string;
            send_max_amount?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("byte_fee" in data && data.byte_fee != undefined) {
                    this.byte_fee = data.byte_fee;
                }
                if ("send_max_amount" in data && data.send_max_amount != undefined) {
                    this.send_max_amount = data.send_max_amount;
                }
            }
        }
        get byte_fee() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set byte_fee(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get send_max_amount() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set send_max_amount(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            byte_fee?: string;
            send_max_amount?: boolean;
        }): UTXOSpecific {
            const message = new UTXOSpecific({});
            if (data.byte_fee != null) {
                message.byte_fee = data.byte_fee;
            }
            if (data.send_max_amount != null) {
                message.send_max_amount = data.send_max_amount;
            }
            return message;
        }
        toObject() {
            const data: {
                byte_fee?: string;
                send_max_amount?: boolean;
            } = {};
            if (this.byte_fee != null) {
                data.byte_fee = this.byte_fee;
            }
            if (this.send_max_amount != null) {
                data.send_max_amount = this.send_max_amount;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.byte_fee.length)
                writer.writeString(1, this.byte_fee);
            if (this.send_max_amount != false)
                writer.writeBool(2, this.send_max_amount);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UTXOSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UTXOSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.byte_fee = reader.readString();
                        break;
                    case 2:
                        message.send_max_amount = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UTXOSpecific {
            return UTXOSpecific.deserialize(bytes);
        }
    }
    export class EthereumSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            max_fee_per_gas_wei?: string;
            priority_fee?: string;
            nonce?: number;
            gas_limit?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("max_fee_per_gas_wei" in data && data.max_fee_per_gas_wei != undefined) {
                    this.max_fee_per_gas_wei = data.max_fee_per_gas_wei;
                }
                if ("priority_fee" in data && data.priority_fee != undefined) {
                    this.priority_fee = data.priority_fee;
                }
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
                if ("gas_limit" in data && data.gas_limit != undefined) {
                    this.gas_limit = data.gas_limit;
                }
            }
        }
        get max_fee_per_gas_wei() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set max_fee_per_gas_wei(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get priority_fee() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set priority_fee(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set nonce(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get gas_limit() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set gas_limit(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            max_fee_per_gas_wei?: string;
            priority_fee?: string;
            nonce?: number;
            gas_limit?: string;
        }): EthereumSpecific {
            const message = new EthereumSpecific({});
            if (data.max_fee_per_gas_wei != null) {
                message.max_fee_per_gas_wei = data.max_fee_per_gas_wei;
            }
            if (data.priority_fee != null) {
                message.priority_fee = data.priority_fee;
            }
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            if (data.gas_limit != null) {
                message.gas_limit = data.gas_limit;
            }
            return message;
        }
        toObject() {
            const data: {
                max_fee_per_gas_wei?: string;
                priority_fee?: string;
                nonce?: number;
                gas_limit?: string;
            } = {};
            if (this.max_fee_per_gas_wei != null) {
                data.max_fee_per_gas_wei = this.max_fee_per_gas_wei;
            }
            if (this.priority_fee != null) {
                data.priority_fee = this.priority_fee;
            }
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            if (this.gas_limit != null) {
                data.gas_limit = this.gas_limit;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.max_fee_per_gas_wei.length)
                writer.writeString(1, this.max_fee_per_gas_wei);
            if (this.priority_fee.length)
                writer.writeString(2, this.priority_fee);
            if (this.nonce != 0)
                writer.writeInt64(3, this.nonce);
            if (this.gas_limit.length)
                writer.writeString(4, this.gas_limit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EthereumSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EthereumSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.max_fee_per_gas_wei = reader.readString();
                        break;
                    case 2:
                        message.priority_fee = reader.readString();
                        break;
                    case 3:
                        message.nonce = reader.readInt64();
                        break;
                    case 4:
                        message.gas_limit = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EthereumSpecific {
            return EthereumSpecific.deserialize(bytes);
        }
    }
    export class THORChainSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            account_number?: number;
            sequence?: number;
            fee?: number;
            is_deposit?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("account_number" in data && data.account_number != undefined) {
                    this.account_number = data.account_number;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("fee" in data && data.fee != undefined) {
                    this.fee = data.fee;
                }
                if ("is_deposit" in data && data.is_deposit != undefined) {
                    this.is_deposit = data.is_deposit;
                }
            }
        }
        get account_number() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set account_number(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get fee() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set fee(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get is_deposit() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set is_deposit(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            account_number?: number;
            sequence?: number;
            fee?: number;
            is_deposit?: boolean;
        }): THORChainSpecific {
            const message = new THORChainSpecific({});
            if (data.account_number != null) {
                message.account_number = data.account_number;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.fee != null) {
                message.fee = data.fee;
            }
            if (data.is_deposit != null) {
                message.is_deposit = data.is_deposit;
            }
            return message;
        }
        toObject() {
            const data: {
                account_number?: number;
                sequence?: number;
                fee?: number;
                is_deposit?: boolean;
            } = {};
            if (this.account_number != null) {
                data.account_number = this.account_number;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.fee != null) {
                data.fee = this.fee;
            }
            if (this.is_deposit != null) {
                data.is_deposit = this.is_deposit;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.account_number != 0)
                writer.writeUint64(1, this.account_number);
            if (this.sequence != 0)
                writer.writeUint64(2, this.sequence);
            if (this.fee != 0)
                writer.writeUint64(3, this.fee);
            if (this.is_deposit != false)
                writer.writeBool(4, this.is_deposit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): THORChainSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new THORChainSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.account_number = reader.readUint64();
                        break;
                    case 2:
                        message.sequence = reader.readUint64();
                        break;
                    case 3:
                        message.fee = reader.readUint64();
                        break;
                    case 4:
                        message.is_deposit = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): THORChainSpecific {
            return THORChainSpecific.deserialize(bytes);
        }
    }
    export class MAYAChainSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            account_number?: number;
            sequence?: number;
            is_deposit?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("account_number" in data && data.account_number != undefined) {
                    this.account_number = data.account_number;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("is_deposit" in data && data.is_deposit != undefined) {
                    this.is_deposit = data.is_deposit;
                }
            }
        }
        get account_number() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set account_number(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get is_deposit() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set is_deposit(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            account_number?: number;
            sequence?: number;
            is_deposit?: boolean;
        }): MAYAChainSpecific {
            const message = new MAYAChainSpecific({});
            if (data.account_number != null) {
                message.account_number = data.account_number;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.is_deposit != null) {
                message.is_deposit = data.is_deposit;
            }
            return message;
        }
        toObject() {
            const data: {
                account_number?: number;
                sequence?: number;
                is_deposit?: boolean;
            } = {};
            if (this.account_number != null) {
                data.account_number = this.account_number;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.is_deposit != null) {
                data.is_deposit = this.is_deposit;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.account_number != 0)
                writer.writeUint64(1, this.account_number);
            if (this.sequence != 0)
                writer.writeUint64(2, this.sequence);
            if (this.is_deposit != false)
                writer.writeBool(3, this.is_deposit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MAYAChainSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MAYAChainSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.account_number = reader.readUint64();
                        break;
                    case 2:
                        message.sequence = reader.readUint64();
                        break;
                    case 3:
                        message.is_deposit = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MAYAChainSpecific {
            return MAYAChainSpecific.deserialize(bytes);
        }
    }
    export class CosmosSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            account_number?: number;
            sequence?: number;
            gas?: number;
            transaction_type?: TransactionType;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("account_number" in data && data.account_number != undefined) {
                    this.account_number = data.account_number;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("gas" in data && data.gas != undefined) {
                    this.gas = data.gas;
                }
                if ("transaction_type" in data && data.transaction_type != undefined) {
                    this.transaction_type = data.transaction_type;
                }
            }
        }
        get account_number() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set account_number(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get sequence() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get gas() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set gas(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get transaction_type() {
            return pb_1.Message.getFieldWithDefault(this, 4, TransactionType.TRANSACTION_TYPE_UNSPECIFIED) as TransactionType;
        }
        set transaction_type(value: TransactionType) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            account_number?: number;
            sequence?: number;
            gas?: number;
            transaction_type?: TransactionType;
        }): CosmosSpecific {
            const message = new CosmosSpecific({});
            if (data.account_number != null) {
                message.account_number = data.account_number;
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.gas != null) {
                message.gas = data.gas;
            }
            if (data.transaction_type != null) {
                message.transaction_type = data.transaction_type;
            }
            return message;
        }
        toObject() {
            const data: {
                account_number?: number;
                sequence?: number;
                gas?: number;
                transaction_type?: TransactionType;
            } = {};
            if (this.account_number != null) {
                data.account_number = this.account_number;
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.gas != null) {
                data.gas = this.gas;
            }
            if (this.transaction_type != null) {
                data.transaction_type = this.transaction_type;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.account_number != 0)
                writer.writeUint64(1, this.account_number);
            if (this.sequence != 0)
                writer.writeUint64(2, this.sequence);
            if (this.gas != 0)
                writer.writeUint64(3, this.gas);
            if (this.transaction_type != TransactionType.TRANSACTION_TYPE_UNSPECIFIED)
                writer.writeEnum(4, this.transaction_type);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CosmosSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CosmosSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.account_number = reader.readUint64();
                        break;
                    case 2:
                        message.sequence = reader.readUint64();
                        break;
                    case 3:
                        message.gas = reader.readUint64();
                        break;
                    case 4:
                        message.transaction_type = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CosmosSpecific {
            return CosmosSpecific.deserialize(bytes);
        }
    }
    export class SolanaSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [[3], [4]];
        constructor(data?: any[] | ({
            recent_block_hash?: string;
            priority_fee?: string;
        } & (({
            from_token_associated_address?: string;
        }) | ({
            to_token_associated_address?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("recent_block_hash" in data && data.recent_block_hash != undefined) {
                    this.recent_block_hash = data.recent_block_hash;
                }
                if ("priority_fee" in data && data.priority_fee != undefined) {
                    this.priority_fee = data.priority_fee;
                }
                if ("from_token_associated_address" in data && data.from_token_associated_address != undefined) {
                    this.from_token_associated_address = data.from_token_associated_address;
                }
                if ("to_token_associated_address" in data && data.to_token_associated_address != undefined) {
                    this.to_token_associated_address = data.to_token_associated_address;
                }
            }
        }
        get recent_block_hash() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set recent_block_hash(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get priority_fee() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set priority_fee(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get from_token_associated_address() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set from_token_associated_address(value: string) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_from_token_associated_address() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get to_token_associated_address() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set to_token_associated_address(value: string) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
        }
        get has_to_token_associated_address() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get _from_token_associated_address() {
            const cases: {
                [index: number]: "none" | "from_token_associated_address";
            } = {
                0: "none",
                3: "from_token_associated_address"
            };
            return cases[pb_1.Message.computeOneofCase(this, [3])];
        }
        get _to_token_associated_address() {
            const cases: {
                [index: number]: "none" | "to_token_associated_address";
            } = {
                0: "none",
                4: "to_token_associated_address"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4])];
        }
        static fromObject(data: {
            recent_block_hash?: string;
            priority_fee?: string;
            from_token_associated_address?: string;
            to_token_associated_address?: string;
        }): SolanaSpecific {
            const message = new SolanaSpecific({});
            if (data.recent_block_hash != null) {
                message.recent_block_hash = data.recent_block_hash;
            }
            if (data.priority_fee != null) {
                message.priority_fee = data.priority_fee;
            }
            if (data.from_token_associated_address != null) {
                message.from_token_associated_address = data.from_token_associated_address;
            }
            if (data.to_token_associated_address != null) {
                message.to_token_associated_address = data.to_token_associated_address;
            }
            return message;
        }
        toObject() {
            const data: {
                recent_block_hash?: string;
                priority_fee?: string;
                from_token_associated_address?: string;
                to_token_associated_address?: string;
            } = {};
            if (this.recent_block_hash != null) {
                data.recent_block_hash = this.recent_block_hash;
            }
            if (this.priority_fee != null) {
                data.priority_fee = this.priority_fee;
            }
            if (this.from_token_associated_address != null) {
                data.from_token_associated_address = this.from_token_associated_address;
            }
            if (this.to_token_associated_address != null) {
                data.to_token_associated_address = this.to_token_associated_address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.recent_block_hash.length)
                writer.writeString(1, this.recent_block_hash);
            if (this.priority_fee.length)
                writer.writeString(2, this.priority_fee);
            if (this.has_from_token_associated_address)
                writer.writeString(3, this.from_token_associated_address);
            if (this.has_to_token_associated_address)
                writer.writeString(4, this.to_token_associated_address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SolanaSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SolanaSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.recent_block_hash = reader.readString();
                        break;
                    case 2:
                        message.priority_fee = reader.readString();
                        break;
                    case 3:
                        message.from_token_associated_address = reader.readString();
                        break;
                    case 4:
                        message.to_token_associated_address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SolanaSpecific {
            return SolanaSpecific.deserialize(bytes);
        }
    }
    export class PolkadotSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            recent_block_hash?: string;
            nonce?: number;
            current_block_number?: string;
            spec_version?: number;
            transaction_version?: number;
            genesis_hash?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("recent_block_hash" in data && data.recent_block_hash != undefined) {
                    this.recent_block_hash = data.recent_block_hash;
                }
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
                if ("current_block_number" in data && data.current_block_number != undefined) {
                    this.current_block_number = data.current_block_number;
                }
                if ("spec_version" in data && data.spec_version != undefined) {
                    this.spec_version = data.spec_version;
                }
                if ("transaction_version" in data && data.transaction_version != undefined) {
                    this.transaction_version = data.transaction_version;
                }
                if ("genesis_hash" in data && data.genesis_hash != undefined) {
                    this.genesis_hash = data.genesis_hash;
                }
            }
        }
        get recent_block_hash() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set recent_block_hash(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set nonce(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get current_block_number() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set current_block_number(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get spec_version() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set spec_version(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get transaction_version() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set transaction_version(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get genesis_hash() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set genesis_hash(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            recent_block_hash?: string;
            nonce?: number;
            current_block_number?: string;
            spec_version?: number;
            transaction_version?: number;
            genesis_hash?: string;
        }): PolkadotSpecific {
            const message = new PolkadotSpecific({});
            if (data.recent_block_hash != null) {
                message.recent_block_hash = data.recent_block_hash;
            }
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            if (data.current_block_number != null) {
                message.current_block_number = data.current_block_number;
            }
            if (data.spec_version != null) {
                message.spec_version = data.spec_version;
            }
            if (data.transaction_version != null) {
                message.transaction_version = data.transaction_version;
            }
            if (data.genesis_hash != null) {
                message.genesis_hash = data.genesis_hash;
            }
            return message;
        }
        toObject() {
            const data: {
                recent_block_hash?: string;
                nonce?: number;
                current_block_number?: string;
                spec_version?: number;
                transaction_version?: number;
                genesis_hash?: string;
            } = {};
            if (this.recent_block_hash != null) {
                data.recent_block_hash = this.recent_block_hash;
            }
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            if (this.current_block_number != null) {
                data.current_block_number = this.current_block_number;
            }
            if (this.spec_version != null) {
                data.spec_version = this.spec_version;
            }
            if (this.transaction_version != null) {
                data.transaction_version = this.transaction_version;
            }
            if (this.genesis_hash != null) {
                data.genesis_hash = this.genesis_hash;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.recent_block_hash.length)
                writer.writeString(1, this.recent_block_hash);
            if (this.nonce != 0)
                writer.writeUint64(2, this.nonce);
            if (this.current_block_number.length)
                writer.writeString(3, this.current_block_number);
            if (this.spec_version != 0)
                writer.writeUint32(4, this.spec_version);
            if (this.transaction_version != 0)
                writer.writeUint32(5, this.transaction_version);
            if (this.genesis_hash.length)
                writer.writeString(6, this.genesis_hash);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PolkadotSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PolkadotSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.recent_block_hash = reader.readString();
                        break;
                    case 2:
                        message.nonce = reader.readUint64();
                        break;
                    case 3:
                        message.current_block_number = reader.readString();
                        break;
                    case 4:
                        message.spec_version = reader.readUint32();
                        break;
                    case 5:
                        message.transaction_version = reader.readUint32();
                        break;
                    case 6:
                        message.genesis_hash = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PolkadotSpecific {
            return PolkadotSpecific.deserialize(bytes);
        }
    }
    export class CoinKeyValuePair extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            key?: string;
            value?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set key(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            key?: string;
            value?: string;
        }): CoinKeyValuePair {
            const message = new CoinKeyValuePair({});
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                key?: string;
                value?: string;
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key.length)
                writer.writeString(1, this.key);
            if (this.value.length)
                writer.writeString(2, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CoinKeyValuePair {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CoinKeyValuePair();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readString();
                        break;
                    case 2:
                        message.value = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CoinKeyValuePair {
            return CoinKeyValuePair.deserialize(bytes);
        }
    }
    export class SuiSpecific extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            reference_gas_price?: string;
            coin_key_value_pairs?: CoinKeyValuePair[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("reference_gas_price" in data && data.reference_gas_price != undefined) {
                    this.reference_gas_price = data.reference_gas_price;
                }
                if ("coin_key_value_pairs" in data && data.coin_key_value_pairs != undefined) {
                    this.coin_key_value_pairs = data.coin_key_value_pairs;
                }
            }
        }
        get reference_gas_price() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set reference_gas_price(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get coin_key_value_pairs() {
            return pb_1.Message.getRepeatedWrapperField(this, CoinKeyValuePair, 2) as CoinKeyValuePair[];
        }
        set coin_key_value_pairs(value: CoinKeyValuePair[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            reference_gas_price?: string;
            coin_key_value_pairs?: ReturnType<typeof CoinKeyValuePair.prototype.toObject>[];
        }): SuiSpecific {
            const message = new SuiSpecific({});
            if (data.reference_gas_price != null) {
                message.reference_gas_price = data.reference_gas_price;
            }
            if (data.coin_key_value_pairs != null) {
                message.coin_key_value_pairs = data.coin_key_value_pairs.map(item => CoinKeyValuePair.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                reference_gas_price?: string;
                coin_key_value_pairs?: ReturnType<typeof CoinKeyValuePair.prototype.toObject>[];
            } = {};
            if (this.reference_gas_price != null) {
                data.reference_gas_price = this.reference_gas_price;
            }
            if (this.coin_key_value_pairs != null) {
                data.coin_key_value_pairs = this.coin_key_value_pairs.map((item: CoinKeyValuePair) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.reference_gas_price.length)
                writer.writeString(1, this.reference_gas_price);
            if (this.coin_key_value_pairs.length)
                writer.writeRepeatedMessage(2, this.coin_key_value_pairs, (item: CoinKeyValuePair) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SuiSpecific {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SuiSpecific();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.reference_gas_price = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.coin_key_value_pairs, () => pb_1.Message.addToRepeatedWrapperField(message, 2, CoinKeyValuePair.deserialize(reader), CoinKeyValuePair));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SuiSpecific {
            return SuiSpecific.deserialize(bytes);
        }
    }
}
